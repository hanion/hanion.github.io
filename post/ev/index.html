<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Engineering an electric vehicle - hanion.dev</title>
		<meta property=      "og:title" content="Engineering an electric vehicle - hanion.dev"/>
		<meta name=       "description" content="Building an EV and working on VCU, telemetry, ADAS, motor drivers, and dashboard systems."/>
		<meta property="og:description" content="Building an EV and working on VCU, telemetry, ADAS, motor drivers, and dashboard systems."/>

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="icon" type="image/png" href="/asset/favicon.png"/>
		<link rel="alternate" type="application/rss+xml" title="hanion.dev rss feed" href="/rss.xml" />

		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link rel="stylesheet" href="/asset/reset.css"/>
		<link rel="stylesheet" href="/asset/style.css"/>
<script> if (localStorage.getItem("theme") === "alt-theme") { document.documentElement.classList.add("alt-theme"); } </script>
	</head>
	<body>
		<div class="wrapper"><nav class="site-nav">
	<div class="nav-left">
		<a href="/">hanion.dev</a>
	</div>
	<div class="nav-right">
		<a href="/archive">archive</a>
		<a href="/rss.xml">rss</a>
<a id="theme-toggle">theme</a>

<script>
const toggleBtn = document.getElementById("theme-toggle");
toggleBtn.addEventListener("click", () => {
	document.documentElement.classList.toggle("alt-theme");
	if (document.documentElement.classList.contains("alt-theme")) {
		localStorage.setItem("theme", "alt-theme");
	} else {
		localStorage.removeItem("theme");
	}
});
</script>
	</div>
</nav>
			<header>
				<h1>Engineering an electric vehicle</h1>
				<p class="date">2025-09-27</p>
				<p class="tags">embedded stm32 lora vcu adas raspberry pi motor control
				</p>
			</header>

			<main class="content"><figure>
	<img src="car.jpg" loading="lazy" alt="The Electric Vehicle">
	<figcaption>The Electric Vehicle</figcaption>
</figure>

<p>
I was part of a team building a high-performance electric vehicle for the Teknofest Efficiency Challenge 2025.
</p>

<p>
I worked on the VCU (Vehicle Control Unit), the telemetry system,
the ADAS (Advanced Driver Assistance Systems) components,
the dashboard display, parts of the motor driver.
</p>

<h1>Vehicular Control Unit</h1>
<figure>
	<img src="vcu.png" loading="lazy" alt="Vehicular Control Unit">
	<figcaption>Vehicular Control Unit</figcaption>
</figure>

<p>
I maintained and extended the VCU software running on STM32 microcontrollers.
</p>

<p>
The VCU is the heart of the car.
Throttle input comes here first, then it forwards commands to the motor drivers,
which run their PID loops and actually move the vehicle.
It also talks to the battery management system, collects status data,
reacts when needed, and pushes that information to the displays.
</p>
<figure>
	<img src="vcu_simplified.png" loading="lazy" alt="VCU Simplified">
	<figcaption>VCU Simplified</figcaption>
</figure>

<p>
Most of this runs over CAN bus.
The VCU also had a screen right behind the wheel, connected over RS232,
showing speed, tachometer, battery percentage, warning lights, and other essentials.
Separate from that, there was a larger dashboard screen.
</p>

<p>
This was the core system, ensuring reliable communication between the motors, battery, and displays.
</p>

<h1>Motor Driver</h1>
<figure>
	<img src="md0.png" loading="lazy" alt="Motor Driver">
	<figcaption>Motor Driver</figcaption>
</figure>

<p>
The motor drivers received commands from the VCU over CAN bus and controlled torque and speed.
They communicate with the VCU over CAN bus, both drivers are on the same line, each with its own ID,
one spinning clockwise and the other counter-clockwise so the wheels move in the same direction.
</p>

<p>
I joined the team after the initial firmware was written, I maintained and improved it.
</p>

<p>
At first the system used torque control, which caused issues under load.
When the car went up a hill the controller tried to hold torque steady,
pulling more and more current until the MOSFETs exploded.
After switching to current control the drivers became stable and we didn't see those failures again.
</p>

<h1>Telemetry System</h1>
<figure>
	<img src="lora.jpg" loading="lazy" alt="VCU and Telemetry System">
	<figcaption>VCU and Telemetry System</figcaption>
</figure>

<p>
The competition required the car to send performance data to a watch center every second.
If the connection dropped, the system had to store the data locally until reconnection,
but it wasn't allowed to save anything while the link was up.
</p>

<p>
At first, the team tried a Teltonika FMC650 using GSM.
I spent time setting it up and integrating it with the VCU,
but it was unreliable, and the VCU had no way to know if data was actually sent.
</p>
<figure>
	<img src="lora_packet.png" loading="lazy" alt="LoRa Packet">
	<figcaption>LoRa Packet</figcaption>
</figure>

<p>
We switched to LoRa, which is simple and requires no GSM or server.
I designed a packet system with IDs and acknowledgments to ensure nothing was lost.
Failed packets were retried a finite number of times, and if all failed, written to SD.
The system proved robust and reliable.
</p>

<p>
I also made a cross-platform listening station interface in Qt,
but in hindsight Dear ImGui would have been simpler, more portable, and faster to develop.
</p>

<h1>Advanced Driver Assistance Systems</h1>
<figure>
	<img src="pi.jpg" loading="lazy" alt="ADAS Raspberry Pi">
	<figcaption>ADAS Raspberry Pi</figcaption>
</figure>

<p>
I developed the software running on the Raspberry Pi,
which handled ADAS features and the dashboard display.
It managed sensor data, GPS, blind spot sensors, the back-facing camera, and automatic headlights.
</p>

<p>
I also wrote a process manager in Go to monitor services,
log everything with timestamps, restart failed processes,
and keep all functions running reliably.
</p>

<p>
The LCD was a simple Python script that displayed the Pi's IP for SSH access during development and debugging.
</p>

<p>
NavMap displayed the race track using GPS data from a u-blox module and positioned the track map accordingly.
</p>

<p>
The dashboard also showed the back-facing camera feed when the car was reversing.
The front camera and line-tracking AI were part of ADAS but were developed by another teammate.
</p>

<p>
Altogether, the Raspberry Pi ran all the software powering the dashboard and ADAS features,
combining navigation, live camera feeds, and sensors into a single, robust system.
</p>

<h1>Reflections</h1>

<p>
Working on this EV let me touch almost every layer of the system,
the VCU, ADAS, telemetry, motor drivers, and the Raspberry Pi dashboard.
</p>

<p>
I learned the importance of having control over the system.
I wrote the telemetry and dashboard software myself and it worked reliably,
which made a big difference compared to the parts I could not control.
</p>

<p>
I also realized that until you test something completely,
you can never be sure it will behave as expected on real hardware.
</p>

<p>
Simple things take longer than expected, and iteration speed is critical.
Long cycles, like with the Teltonika FMC650, make development inefficient.
</p>

<p>
In the end, the project reinforced that control, testing,
and iteration are what make complex systems actually work in practice.
</p>

			</main>
		</div>
	</body>
</html>